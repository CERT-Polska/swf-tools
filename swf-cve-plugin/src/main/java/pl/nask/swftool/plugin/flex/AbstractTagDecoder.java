/*
 * Copyright (c) NASK, NCSC
 * 
 * This file is part of HoneySpider Network 2.0.
 * 
 * This is a free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package pl.nask.swftool.plugin.flex;

import java.io.DataInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.zip.InflaterInputStream;

import flash.swf.Dictionary;
import flash.swf.Header;
import flash.swf.SwfDecoder;
import flash.swf.Tag;
import flash.swf.TagHandler;
import flash.swf.tags.CSMTextSettings;
import flash.swf.tags.DefineEditText;
import flash.swf.tags.DefineFont;
import flash.swf.tags.DefineFont3;
import flash.swf.tags.DefineFontAlignZones;
import flash.swf.tags.DefineFontName;
import flash.swf.tags.DefineText;
import flash.swf.tags.FileAttributes;
import flash.swf.tags.ProductInfo;
import flash.swf.tags.ZoneRecord;
import flash.swf.types.Rect;

public abstract class AbstractTagDecoder {
	private InputStream swfIn;
	private InputStream swdIn;
	protected SwfDecoder r;
	private TagHandler handler;
	private Header header;
    private Dictionary dict = new Dictionary();

    /**
     * thrown by decoders when we have a fatal error.  Many errors
     * are not fatal.  In those cases, the error is reported but
     * parsing continues.
     */
	public static class FatalParseException extends Exception {
        private static final long serialVersionUID = 5819679367367802771L;
    }
	
	public AbstractTagDecoder(InputStream swfIn) {
		this.swfIn = swfIn;
	}
	
	/**
     * process the whole SWF stream, and close the input streams when finished.
     * @param handler
     * @throws IOException
     */
	public boolean parse(TagHandler handler) throws IOException
	{
		boolean result = false;

        this.handler = handler;
        try
        {
            try
            {
                handler.setDecoderDictionary( dict );

                header = decodeHeader();
                handler.header( header );

                result = decodeTags( handler );
                handler.finish();
                return result;
            }
            catch( FatalParseException e )
            {
                // errors already reported to TagHandler.
            	System.err.println("FatalParseException: " + e);
            }
            finally
            {
                if ( swfIn != null )
                    swfIn.close();
            }
        }
        finally
        {
            if ( swdIn != null )
                swdIn.close();
        }

        return result;
	}
	
	public Header decodeHeader() throws IOException, FatalParseException
    {
        Header header = new Header();
        byte[] sig = new byte[8];

        new DataInputStream(swfIn).readFully(sig);
        header.version = sig[3];
        header.length = sig[4]&0xFF | (sig[5]&0xFF)<<8 | (sig[6]&0xFF)<<16 | sig[7]<<24;

        if (sig[0] == 'C' && sig[1] == 'W' && sig[2] == 'S')
        {
            header.compressed = true;
            r = new SwfDecoder(new InflaterInputStream(swfIn), header.version, 8);
        }
        else if (sig[0] == 'F' || sig[1] == 'W' || sig[2] == 'S')
        {
            r = new SwfDecoder(swfIn, header.version, 8);
        }
        else
        {
            handler.error("Invalid signature found.  Not a SWF file");
            throw new FatalParseException();
        }

        header.size = decodeRect();
        header.rate = r.readUI8() << 8 | r.readUI8();
        header.framecount = r.readUI16();

        return header;
    }
	
	private Rect decodeRect() throws IOException
    {
        r.syncBits();

        Rect rect = new Rect();

        int nBits = r.readUBits(5);
        rect.xMin = r.readSBits(nBits);
        rect.xMax = r.readSBits(nBits);
        rect.yMin = r.readSBits(nBits);
        rect.yMax = r.readSBits(nBits);

        return rect;
    }
	
	public int getSwfVersion()
	{
		return header.version;
	}

	protected abstract boolean decodeTags(TagHandler handler) throws IOException;
	
	
	
  public int readSI32(byte[] buf) throws IOException
  {
      int i;

      i = buf[0] & 0xFF | (buf[0 + 1] & 0xFF) << 8 | (buf[0 + 2] & 0xFF) << 16 | buf[0 + 3] << 24;

      return i;
  }

  public static int GetEncodedU32( byte[] pos )
  {
  	int result = pos[0];

  	if (  (result & 0x00000080) == 0 )
  	{
  		return result;
  	}
  	result = ( result & 0x0000007f ) | pos[1] << 7;

  	if ( ( result & 0x00004000 ) == 0 )
  	{
  		return result;
  	}
  	result = ( result & 0x00003fff ) | pos[2] << 14;

  	if ( ( result & 0x00200000 ) == 0 )
  	{
  		return result;
  	}
  	result = ( result & 0x001fffff ) | pos[3] << 21;

  	if ( ( result & 0x10000000 ) == 0 )
  	{
  		return result;
  	}
  	result = ( result & 0x0fffffff ) | pos[4] << 28;

  	return result;
  }
	
	
	/*
	 * 
	 * some additional public methods 
	 * 
	 */
	
    public Tag decodeFileAttributes() throws IOException
    {
        FileAttributes tag = new FileAttributes();
        r.syncBits();
        r.readUBits(3); //reserved
        tag.hasMetadata = r.readBit();
        tag.actionScript3 = r.readBit();
        tag.suppressCrossDomainCaching = r.readBit();
        tag.swfRelativeUrls = r.readBit();
        tag.useNetwork = r.readBit();
        r.readUBits(24); //reserved
        return tag;
    }

    public Tag decodeDefineFontAlignZones() throws IOException
    {
        DefineFontAlignZones zones = new DefineFontAlignZones();
        int fontID = r.readUI16();
        zones.font = (DefineFont3)dict.getTag(fontID);
        zones.font.zones = zones;
        zones.csmTableHint = r.readUBits(2);
        r.readUBits(6);  // reserved
        zones.zoneTable = new ZoneRecord[zones.font.glyphShapeTable.length];
        for (int i = 0; i < zones.font.glyphShapeTable.length; i++)
        {
            ZoneRecord record = new ZoneRecord();
            zones.zoneTable[i] = record;
            record.numZoneData = r.readUI8();
            record.zoneData = new long[record.numZoneData];
            for (int j = 0; j < record.numZoneData; j++)
            {
                record.zoneData[j] = r.readUI32();
            }
            record.zoneMask = r.readUI8();
        }
        return zones;
    }

    public Tag decodeCSMTextSettings() throws IOException
    {
        CSMTextSettings tag = new CSMTextSettings();
        int textID = r.readUI16();
        if (textID != 0)
        {
            tag.textReference = dict.getTag(textID);
            if (tag.textReference instanceof DefineText)
            {
                ((DefineText)tag.textReference).csmTextSettings = tag;
            }
            else if (tag.textReference instanceof DefineEditText)
            {
                ((DefineEditText)tag.textReference).csmTextSettings = tag;
            }
            else
            {
                handler.error("CSMTextSettings' textID must reference a valid DefineText or DefineEditText.  References " + tag.textReference);
            }
        }
        tag.styleFlagsUseSaffron = r.readUBits(2);
        tag.gridFitType = r.readUBits(3);
        r.readUBits(3); // reserved
        // FIXME: thickness/sharpness should be read in as 32 bit IEEE Single Precision format in little Endian
        tag.thickness = r.readUBits(32);
        tag.sharpness = r.readUBits(32);
        r.readUBits(8); // reserved
        return tag;
    }

	public Tag decodeDefineFontName() throws IOException
	{
	    DefineFontName tag = new DefineFontName();
	    int fontID = r.readUI16();
	    tag.font = (DefineFont)dict.getTag(fontID);
	    tag.font.license = tag;
		tag.fontName = r.readString();
		tag.copyright = r.readString();
		return tag;
	}
	
    public Tag decodeSerialNumber() throws IOException
    {
        int product = r.readSI32();
        int edition = r.readSI32();

        byte[] version = new byte[2];
        r.read(version);
        byte majorVersion = version[0];
        byte minorVersion = version[1];

        long build = r.read64();
        long compileDate = r.read64();

        return new ProductInfo(product, edition, majorVersion, minorVersion, build, compileDate);
    }
}
